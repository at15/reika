\documentclass{article}

\usepackage[final,nonatbib]{nips_2017}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography

\usepackage[backend=biber]{biblatex}
\addbibresource{re-reika.bib}

\usepackage{graphicx}
\graphicspath{ {images/} }

% https://tex.stackexchange.com/questions/376420/include-chinese-characters-into-article-in-xelatex
\usepackage{fontspec}
\newfontfamily\cjkfont{Noto Sans CJK SC}

\usepackage{listings}

\title{Re-Reika: Engineering a DSL compiler}

\author{
Pinglei Guo \\
\texttt{piguo@ucsc.edu}
}

\begin{document}

\maketitle

\begin{abstract}
    % TODO: update abstract
    A compiler for DSL
\end{abstract}

\section{Introduction}
\label{sec:introduction}

\subsection{Motivation and Accomplishment}
\label{subsec:motivation}

We decided to continue the development of Reika \footnote{\url{https://github.com/xephonhq/tsdb-proxy-java/tree/master/ql}},
a DSL for time series database previously built in CMPS203.
\footnote{\href{https://github.com/xephonhq/tsdb-proxy-java/blob/master/ql/Reika\_TSDB\_DSL\_0.0.1.pdf}{Reika\_TSDB\_DSL\_0.0.1.pdf}}.
However, in this quarter, we mainly focused on more detailed design (type system etc.)
and how to make the compiler extensible and maintainable.
Also we no longer limit it to time series data, we want it to be able to handle common data analytic tasks, even simple machine learning.

Due to the duration of the quarter, half of the time was spending on survey and building small prototype.
A survey of q, juila, kotlin, groovy, scala, dotty, weld~\cite{palkar2017weld}'s design and compiler implementation is listed in \verb+doc/dev-notes/at15+.
We implemented simply typed lambda calculus (\verb+simplebool+) and preceding exercises from TAPL in Java.
\footnote{located in tapl folder}
A typecheker, interpreter and transpiler for \verb+SimpleBin+ (only has int and boolean) \footnote{located in playground package of Reika}
to demonstrate how our real implementation is structured and the relation ship between typechecker, interpreter and transpiler.
The real Reika implementation is written from scratch without using old Reika codebase,
and because of a major refactor in the middle \footnote{\url{https://github.com/at15/reika/pull/31}} due to design flaw in AST and compiler phases, the latest version is currently stuck on
\verb+namer+ (symbol and scope) and \verb+typechecker+ phases,
it will be continued and integrate into author's master thesis during winter break and final quarter.

\subsection{Why Reika DSL instead of Python or SQL}
\label{subsec:why-reika}

A common question asked by friends of mine is why don't you just use python,
which is widely used in big data and machine learning as glue language.
The reason is python is not statically typed and it has a lot of legacy,
even though 3.6 adds type hint, most libraries don't have it, not to mention those struggle between python2 and python3.
When you run a python program,
it can execute 999 lines but throw error at last line because you concat a int to string when you try to save the result.

Languages like SQL is typed, but it is checked against schema until it is sent to server,
we want error when I typed invalid column name in editor.
Also there is always a layer of conversion between SQL query result and the code you used to implement bossiness logic
like generating report and graph, extra check is needed everywhere, they should be unified.

We want a language for data analytic that fails fast, has good editor integration.
It should be interactive for exploration and have good performance when run in production.
Which leads to our statically typed, mostly declarative DSL - Reika.

\section{Design}
\label{sec:design}

% TODO: unify compiler, interpreter, transpiler
% TODO: overload vs. type inference
% TODO: phases, parallel phases (immutable trees)

\section{Implementation}
\label{sec:implementation}

% TODO: several stages, TAPL, SimpleBin, Typed Reika
% lexer, handling negative number

\section{Related Work}
\label{sec:related-work}

% TODO: weld
% TODO: RezzoomSQL
% TODO: Dotty, Groovy

\section{Future Work}
\label{sec:future-work}

\section{Conclusion}
\label{sec:conclusion}

\printbibliography

\end{document}
